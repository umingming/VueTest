/**
 * 지수: ⁰¹²³⁴⁵⁶⁷⁸⁹
 * 로그: ₀₁₂₃₄₅₆₇₈₉
 * 특수문자: Θ
 */
export const QUESTIONS = [
    //============================== 2019
    {
        ANSWER: "입출, 명, 유, 유효",
        TITLE: "알고리즘의 조건",
        QUESTION: "ㅇㅇ력, ㅇ확성, ㅇ한성, ㅇㅇ성",
        ITERATION: 2019,
        NO: 1,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 1,
    },
    {
        ANSWER: "이중",
        TITLE: "연결 리스트",
        QUESTION:
            "ㅇㅇ 연결 리스트는 특정 노드에서 선행 노드와 후행 노드에 대한 접근이 모두 가능함.",
        ITERATION: 2019,
        NO: 2,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 1,
    },
    {
        ANSWER: "경로",
        TITLE: "그래프 용어",
        QUESTION:
            "그래프 G에서 정점 v1으로부터 정점 v2까지의 ㅇㅇ(이)란 간선 (v1, v2),(v1, v2), ..., (vn-1, vn)으로 연결된 \r\n정점의 순서 리스트 v1, v2, ..., vn을 의미함.",
        ITERATION: 2019,
        NO: 3,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 4,
    },
    {
        ANSWER: "욕심쟁이, 분할, 동적",
        TITLE: "알고리즘의 대표적인 설계 기법",
        QUESTION: "ㅇㅇㅇㅇ 방법, ㅇㅇ정복 방법, ㅇㅇ 프로그래밍 방법",
        ITERATION: 2019,
        NO: 4,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 1,
    },
    {
        ANSWER: "4",
        TITLE: "점근 성능",
        QUESTION:
            "입력 크기 n에 대한 알고리즘 수행 시간 f(n)=5n³+10n²+8n+200을 점근 성능으로 올바르게 나타낸 것은?\r\n1)O(1)\r\n2)O(n)\r\n3)O(n²)\r\n4)O(n³)",
        ITERATION: 2019,
        NO: 5,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 1,
    },
    {
        ANSWER: "최악, 3",
        TITLE: "점화식과 폐쇄형",
        QUESTION:
            "퀵 정렬 (최악/최선) 알고리즘의 성능으로 T(1)=Θ(1), T(n)=T(n-1)+Θ(n)의 폐쇄형은?\r\n1)T(n)=Θ(logn)\r\n1)T(n)=Θ(logn)\r\n2)T(n)=Θ(n)\r\n3)T(n)=Θ(n²)\r\n4)T(n)=Θ(nlogn)",
        ITERATION: 2019,
        NO: 6,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 1,
    },
    {
        ANSWER: "이진, 1",
        TITLE: "점화식과 폐쇄형",
        QUESTION:
            "ㅇㅇ탐색 알고리즘의 성능으로 T(1)=Θ(1), T(n)=T(n/2)+Θ(1)의 폐쇄형은?\r\n1)T(n)=Θ(logn)\r\n1)T(n)=Θ(logn)\r\n2)T(n)=Θ(n)\r\n3)T(n)=Θ(n²)\r\n4)T(n)=Θ(nlogn)",
        ITERATION: 2019,
        NO: 7,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 1,
    },
    {
        ANSWER: "2",
        TITLE: "점화식과 폐쇄형",
        QUESTION:
            "T(1)=Θ(1), T(n)=T(n/2)+Θ(n)의 폐쇄형은?\r\n1)T(n)=Θ(logn)\r\n1)T(n)=Θ(logn)\r\n2)T(n)=Θ(n)\r\n3)T(n)=Θ(n²)\r\n4)T(n)=Θ(nlogn)",
        ITERATION: 2019,
        NO: 6,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 1,
    },
    {
        ANSWER: "2",
        TITLE: "점화식과 폐쇄형",
        QUESTION:
            "T(1)=Θ(1), T(n)=2T(n/2)+Θ(1)의 폐쇄형은?\r\n1)T(n)=Θ(logn)\r\n1)T(n)=Θ(logn)\r\n2)T(n)=Θ(n)\r\n3)T(n)=Θ(n²)\r\n4)T(n)=Θ(nlogn)",
        ITERATION: 2019,
        NO: 6,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 1,
    },
    {
        ANSWER: "최선, 합병, 4",
        TITLE: "점화식과 폐쇄형",
        QUESTION:
            "퀵 정렬 (최선/최악), ㅇㅇ 정렬 알고리즘의 성능으로 T(1)=Θ(1), T(n)=2T(n/2)+Θ(n)의 폐쇄형은?\r\n1)T(n)=Θ(logn)\r\n1)T(n)=Θ(logn)\r\n2)T(n)=Θ(n)\r\n3)T(n)=Θ(n²)\r\n4)T(n)=Θ(nlogn)",
        ITERATION: 2019,
        NO: 6,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 1,
    },
    {
        ANSWER: "분할, 정복, 결합",
        TITLE: "분할정복 방법",
        QUESTION:
            "분할정복 방법에서 각 순환 호출마다 거치는 작업의 단계: ㅇㅇ -> ㅇㅇ -> ㅇㅇ",
        ITERATION: 2019,
        NO: 6,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 1,
    },
    {
        ANSWER: "25, 10, 20, 15",
        TITLE: "퀵 정렬",
        QUESTION:
            "다음 데이터에 대해서 분할 함수 Partition()을 한 번 적용한 후 왼쪽 부분배열에 존재하는 데이터를 순서대로 기입하시오.\r\n(단, 피벗은 맨 왼쪽 원소이고, 오름차순으로 정렬한다.)\r\n [30, 45, 20, 14, 40, 25, 35, 10]",
        ITERATION: 2019,
        NO: 6,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 2,
    },
    {
        ANSWER: "최악, 최악, 최선, 최악, 최선",
        TITLE: "퀵 정렬의 성능",
        QUESTION:
            "- 분할을 수행할 때마다 항상 피벗이 최솟값 또는 최댓값이 되는 경우: (최선/최악)의 성능\r\n- 피벗만 제자리를 잡고 나머지 모든 데이터가 하나의 부분배열이 되는 경우: (최선/최악)의 성능\r\n - 피벗이 항상 중간값이 되는 경우: (최선/최악)의 성능\r\n- 입력 데이터가 정렬되어 있는 경우: (최선/최악)의 성능\r\n- 피벗을 중심으로 항상 동일한 크기의 두 부분배열로 분할되는 경우: (최선/최악)의 성능\r\n",
        ITERATION: 2019,
        NO: 10,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 2,
    },
    {
        ANSWER: "36",
        TITLE: "퀵 정렬 피벗",
        QUESTION:
            "다음은 입력 크기 38인 배열의 원소를 7개의 그룹으로 구성한 모습이다. 최악 O(n)으로 i번째로 작은 원소를 찾기 위한 선택 문제에서 피벗으로 선택되는 원소는? \r\n[9, 6, 35, 39, 15]\r\n[24, 70, 95, 50, 1]\r\n[97, 84, 77, 28, 10]\r\n[22, 27, 11, 31, 62]\r\n[54, 81, 5, 34, 4]\r\n[89, 60, 29, 2, 75]\r\n[18, 36, 80, 7, 53]\r\n[25, 66, 43]",
        ITERATION: 2019,
        NO: 11,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 2,
    },
    {
        ANSWER: "스트링, 상향, 최적, X",
        TITLE: "동적 프로그래밍 방법",
        QUESTION:
            "- 모든 정점 간의 최단 경로 문제와 ㅇㅇㅇ 편집 거리 문제에 적용된다. \r\n-(상향/하향)식 접근 방법 \r\n- ㅇㅇ성의 원리가 만족되는 문제에만 적용할 수 있다. \r\n- 소문제들은 서로 독립적이어야 한다. (O/X)",
        ITERATION: 2019,
        NO: 12,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 5,
    },
    {
        ANSWER: 13,
        TITLE: "피보나치 수열",
        QUESTION:
            "피보나치 수열 f(n)에서 f(7)은 얼마인가? \r\n (단, f(0) = 0, f(1) = 1이다.)",
        ITERATION: 2019,
        NO: 13,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 5,
    },
    {
        ANSWER: 4,
        TITLE: "행렬의 연쇄적 곱셈",
        QUESTION:
            "동적 프로그래밍 방법을 적용하여 n개의 행렬에 대한 연쇄적 곰셈 문제를 해결하는 알고리즘의 시간 복잡도는?\r\n1)O(nlogn)\r\n2)O(n)\r\n3)O(n²)\r\n4)O(n³)",
        ITERATION: 2019,
        NO: 14,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 5,
    },
    {
        ANSWER: 4,
        TITLE: "플로이드 알고리즘",
        QUESTION:
            "플로이드 알고리즘의 성능 표현으로 올바른 것은? \r\nFloyd (G=(V,E)) { // |V|=n \r\nD[][] <- 입력 간선의 인접 행렬로 초기화\r\nfor (k=1부터 n까지)\r\nfor (i=1부터 n까지)\r\nfor (j=1부터 n까지)\r\nif (D[i][j] > D[i][k] + D[k][j])\r\nD[i][j] = D[i][k] + D[k][j];\r\nreturn D[][];\r\n}\r\n1)O(nlogn)\r\n2)O(n)\r\n3)O(n²)\r\n4)O(n³)",
        ITERATION: 2019,
        NO: 15,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 4,
    },
    {
        ANSWER: "크루스칼, 프림, 데이크스트라",
        TITLE: "욕심쟁이(greedy) 대표 고리즘",
        QUESTION:
            "- 최소 신장 트리: ㅇㅇㅇㅇ 알고리즘, ㅇㅇ 알고리즘 - 단일 출발점에 대한 최단 경로: ㅇㅇㅇㅇㅇ 알고리즘",
        ITERATION: 2019,
        NO: 17,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 1,
    },
    {
        ANSWER: "가중, 작은",
        TITLE: "최소 신장 트리",
        QUESTION:
            "최소 신장 트리는 신장 트리 중에서 ㅇㅇ치의 합이 가장 (큰/작은) 것",
        ITERATION: 2019,
        NO: 18,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 4,
    },
    {
        ANSWER: "T6",
        TITLE: "욕심쟁이 방법",
        QUESTION:
            "욕심쟁이 방법을 적용한 작업 선택 문제에서 기계에 가장 먼저 할당되는 작업은? \r\nT1 = (0, 4), T2 = (4, 8), T3 = (6, 9), T4 = (9, 10), T5 = (1, 6), T6 = (1, 3), T7 = (3, 8), T8 = (4, 6)",
        ITERATION: 2019,
        NO: 19,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 1,
    },
    {
        ANSWER: "비교, 분포",
        TITLE: "정렬 알고리즘",
        QUESTION:
            "- ㅇㅇ 기반의 알고리즘: 선택 정렬, 버블 정렬, 삽입 정렬, 셸 정렬, 퀵 정렬, 합병 정렬, 힙 정렬 \r\n - 데이터의 ㅇㅇ에 기반한 정보를 바탕으로 정을 수행하는 알고리즘: 계수 정렬, 기수 정렬, 버킷 정렬",
        ITERATION: 2019,
        NO: 20,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 2,
    },
    {
        ANSWER: "유지, 불안정, 안정, 안정, 불안정, 불안정, 안정, 불안정, 안정",
        TITLE: "안정적 정렬",
        QUESTION:
            "안정적 정렬은 같은 값을 갖는 여러 개의 데이터에 대한 정렬 전의 상대적 위치가 정렬 후에도 그대로 ㅇㅇ되는 정렬이다.\r\n - 선택 정렬: (안정/불안정)\r\n - 버블 정렬: (안정/불안정)\r\n - 삽입 정렬: (안정/불안정)\r\n - 셸 정렬: (안정/불안정)\r\n - 퀵 정렬: (안정/불안정)\r\n - 합병 정렬: (안정/불안정)\r\n - 힙 정렬: (안정/불안정)\r\n - 데이터 분포 기반의 정렬: (안정/불안정)",
        ITERATION: 2019,
        NO: 21,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 2,
    },
    {
        ANSWER: "10",
        TITLE: "버블 정렬",
        QUESTION:
            "다음 데이터에 대해 버블 정렬을 적용하여 오름차순으로 정렬할 때, 인접한 두 데이터 간의 자리바꿈이 발생하는 총 횟수는? \r\n [50, 40, 30, 20, 10]",
        ITERATION: 2019,
        NO: 22,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 2,
    },
    {
        ANSWER: "선택",
        TITLE: "ㅇㅇ 정렬",
        QUESTION:
            "정렬되지 않은 데이터 중에서 가장 작은 값을 골라서, 이 값과 미정렬 데이터 부분의 첫 번째 원소와 교환하는 방식",
        ITERATION: 2019,
        NO: 23,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 2,
    },
    {
        ANSWER: "O, 안정, O, O",
        TITLE: "삽입 정렬",
        QUESTION:
            "- 입력이 정렬된 상태로 주어지는 최선의 경우 수행시간은 O(n)이다. (O/X)\r\n- (안정/불안정)적인 정렬 알고리즘\r\n- 제자리 정렬 알고리즘이다. (O/X)\r\n- 최악의 수행시간은 O(n²)이다. (O/X)",
        ITERATION: 2019,
        NO: 24,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 2,
    },
    {
        ANSWER: "nlogn, nlogn, 안정, X, O",
        TITLE: "합병 정렬",
        QUESTION:
            "- 최악의 수행시간은 O((n/nlogn))이다. \r\n- 최선의 수행시간은 O((n/nlogn))이다.\r\n- (안정/불안정)적인 정렬 알고리즘\r\n- 제자리 정렬 알고리즘이다. (O/X)\r\n- 분할정복 방법이 적용되었다. (O/X)",
        ITERATION: 2019,
        NO: 25,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 2,
    },
    {
        ANSWER: "O, nlogn, 불안정, O, O",
        TITLE: "퀵 정렬",
        QUESTION:
            "- 최악의 수행시간은 O(n²)이다. (O/X)\r\n- 최선의 수행시간은 O((n/nlogn))이다.\r\n- (안정/불안정)적인 정렬 알고리즘\r\n- 제자리 정렬 알고리즘이다. (O/X)\r\n- 분할정복 방법이 적용되었다. (O/X)",
        ITERATION: 2019,
        NO: 26,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 2,
    },
    {
        ANSWER: "제자리, 넘지 않는",
        TITLE: "ㅇㅇㅇ 정렬 알고리즘",
        QUESTION:
            "입력 데이터를 저장하는 공간 이외에 별도로 필요한 저장 공간이 상수 개를 (넘는/넘지 않는) 정렬 알고리즘",
        ITERATION: 2019,
        NO: 26,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 2,
    },
    {
        ANSWER: "88",
        TITLE: "힙 정렬",
        QUESTION:
            "주어진 데이터를 오름차순으로 힙 정렬할 때, 루트 노드에 존재하는 데이터는? \r\n [10, 7, 15, 88, 50, 30, 40]",
        ITERATION: 2019,
        NO: 27,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 2,
    },
    {
        ANSWER: "X, 상수, X, 안정, n",
        TITLE: "기수 정렬",
        QUESTION:
            "- 비교 기반의 정렬 알고리즘이다. (O/X)\r\n - 입력 데이터의 자릿수가 ㅇㅇ일 때 유용하다.\r\n - 제자리 정렬 알고리즘이다. (O/X)\r\n - (안정/불안정) 정렬 알고리즘이다.\r\n - 시간 복잡도는 O((n/n의 제곱))이다.",
        ITERATION: 2019,
        NO: 28,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 2,
    },
    {
        ANSWER: "비정렬, 작은, O, 1, n, n, 1",
        TITLE: "순차 탐색",
        QUESTION:
            "- (정렬/비정렬) 데이터에 적합하다.\r\n - 크기가 (큰/작은) 데이터에 적합하다.\r\n - 리스트 형태의 입력에 언제라도 적용이 가능하다. (O/X)\r\n - 탐색 키가 존재하는 경우에는 최소 (1/n)번의 비교가 필요하다.\r\n - 탐색 키가 존재하지 않는 경우 항상 (n의 제곱/n)번의 비교가 필요하다.\r\n - 탐색과 삭제 연산의 시간 복잡도는 O((n/n의 제곱))이다.\r\n - 삽입 연산의 시간 복잡도는 O((1/n/logn))이다.",
        ITERATION: 2019,
        NO: 29,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 3,
    },
    {
        ANSWER: "정렬, 작은, logn, nlogn, n",
        TITLE: "이진 탐색",
        QUESTION:
            "- (정렬/비정렬) 데이터에 적합하다.\r\n - 크기가 (큰/작은) 데이터에 적합하다.\r\n - 탐색 연산의 시간 복잡도는 O((n/logn/nlogn))이다.\r\n - 초기화 연산의 시간 복잡도는 O((n/logn/nlogn))이다.\r\n - 삽입과 삭제 연산의 시간 복잡도는 O((n/logn/nlogn))이다.",
        ITERATION: 2019,
        NO: 30,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 3,
    },
    {
        ANSWER: "균형, 검정, 검정, 검정, 작다, 크다",
        TITLE: "레드-블랙 트리(흑적 트리)",
        QUESTION:
            "흑적 트리는 모든 노드에 대해 다음 성질을 만족하는 이진 트리인 ㅇㅇ 탐색 트리이다. \r\n- 모든 노드는 검정이거나 빨강이다. \r\n- 루프 노드와 리프 노드는 (검정/빨강)이다.\r\n- 빨강 노드의 부모 노드는 항상 (검정/빨강)이다.\r\n- 임의의 노드로부터 리프 노드까지의 경로상에는 동일한 개수의 (검정/빨강) 노드가 존재한다.\r\n- 한 노드의 왼쪽 서브트리에 있는 모든 키 값은 그 노드의 키값보다 (작다/크다).\r\n- 한 노드의 오른쪽 서브트리에 있는 모든 키 값은 그 노드의 키값보다 (크다/작다).",
        ITERATION: 2019,
        NO: 31,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 3,
    },
    {
        ANSWER: 4,
        TITLE: "탐색 트리",
        QUESTION:
            "모든 리프 노드의 레벨이 동일한 트리는? \r\n 1) 흑적 트리\r\n 2) 이진 탐색 트리\r\n 3) 완전 이진 트리\r\n 4) B-트리",
        ITERATION: 2019,
        NO: 32,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 3,
    },
    {
        ANSWER: "1, logn, logn, n, logn, logn, logn",
        TITLE: "탐색 연산의 시간 복잡도",
        QUESTION:
            "- 이진 탐색 최선: O((1/n/logn))\r\n- 이진 탐색 최악: O((n/logn/nlogn))\r\n- 이진 탐색 트리 최선: O((1/n/logn))\r\n- 이진 탐색 트리 최악: O((n/logn/nlogn))\r\n- 2-3-4 트리: O((n/logn/nlogn))\r\n- 레드-블랙 트리: O((n/logn/nlogn))\r\n- B-트리: O((n/logn/nlogn))\r\n",
        ITERATION: 2019,
        NO: 33,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 3,
    },
    {
        ANSWER: 2,
        TITLE: "근사 알고리즘",
        QUESTION:
            "다음 NP-완전 문제의 근사 알고리즘을 통해 해결할 수 있는 문제는? \r\n- 주어진 그래프의 최소 신장 트리를 구한다.\r\n- 임의의 정점 하나를 루트 노드로 지정해서 최소 신장 트리를 깊이 우선 탐색 순서대로 정점을 나열하고 마지막에 첫 정점을 한 번 더 추가한다.\r\n1) 버텍스 커버 문제\r\n2) 외판원 문제\r\n3) CNF-만족성 문제\r\n4) 클리크 판정 문제",
        ITERATION: 2019,
        NO: 35,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 7,
    },
];
