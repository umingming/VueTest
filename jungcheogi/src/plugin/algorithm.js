/**
 * 지수: ⁰¹²³⁴⁵⁶⁷⁸⁹
 * 로그: ₀₁₂₃₄₅₆₇₈₉
 * 특수문자: Θ
 */
export const QUESTIONS = [
    //============================== 2019
    {
        ANSWER: "입출, 명, 유, 유효",
        TITLE: "알고리즘의 조건",
        QUESTION: "ㅇㅇ력, ㅇ확성, ㅇ한성, ㅇㅇ성",
        ITERATION: 2019,
        NO: 1,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 1,
    },
    {
        ANSWER: "이중",
        TITLE: "연결 리스트",
        QUESTION:
            "ㅇㅇ 연결 리스트는 특정 노드에서 선행 노드와 후행 노드에 대한 접근이 모두 가능함.",
        ITERATION: 2019,
        NO: 2,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 1,
    },
    {
        ANSWER: "경로",
        TITLE: "그래프 용어",
        QUESTION:
            "그래프 G에서 정점 v1으로부터 정점 v2까지의 ㅇㅇ(이)란 간선 (v1, v2),(v1, v2), ..., (vn-1, vn)으로 연결된 \r\n정점의 순서 리스트 v1, v2, ..., vn을 의미함.",
        ITERATION: 2019,
        NO: 3,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 4,
    },
    {
        ANSWER: "욕심쟁이, 분할, 동적",
        TITLE: "알고리즘의 대표적인 설계 기법",
        QUESTION: "ㅇㅇㅇㅇ 방법, ㅇㅇ정복 방법, ㅇㅇ 프로그래밍 방법",
        ITERATION: 2019,
        NO: 4,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 1,
    },
    {
        ANSWER: "4",
        TITLE: "점근 성능",
        QUESTION:
            "입력 크기 n에 대한 알고리즘 수행 시간 f(n)=5n³+10n²+8n+200을 점근 성능으로 올바르게 나타낸 것은?\r\n1)O(1)\r\n2)O(n)\r\n3)O(n²)\r\n4)O(n³)",
        ITERATION: 2019,
        NO: 5,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 1,
    },
    {
        ANSWER: "최악, 3",
        TITLE: "점화식과 폐쇄형",
        QUESTION:
            "퀵 정렬 (최악/최선) 알고리즘의 성능으로 T(1)=Θ(1), T(n)=T(n-1)+Θ(n)의 폐쇄형은?\r\n11)T(n)=Θ(logn)\r\n2)T(n)=Θ(n)\r\n3)T(n)=Θ(n²)\r\n4)T(n)=Θ(nlogn)",
        ITERATION: 2019,
        NO: 6,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 1,
    },
    {
        ANSWER: "이진, 1",
        TITLE: "점화식과 폐쇄형",
        QUESTION:
            "ㅇㅇ탐색 알고리즘의 성능으로 T(1)=Θ(1), T(n)=T(n/2)+Θ(1)의 폐쇄형은?\r\n1)T(n)=Θ(logn)\r\n2)T(n)=Θ(n)\r\n3)T(n)=Θ(n²)\r\n4)T(n)=Θ(nlogn)",
        ITERATION: 2019,
        NO: 7,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 1,
    },
    {
        ANSWER: "2",
        TITLE: "점화식과 폐쇄형",
        QUESTION:
            "T(1)=Θ(1), T(n)=T(n/2)+Θ(n)의 폐쇄형은?\r\n1)T(n)=Θ(logn)\r\n2)T(n)=Θ(n)\r\n3)T(n)=Θ(n²)\r\n4)T(n)=Θ(nlogn)",
        ITERATION: 2019,
        NO: 6,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 1,
    },
    {
        ANSWER: "2",
        TITLE: "점화식과 폐쇄형",
        QUESTION:
            "T(1)=Θ(1), T(n)=2T(n/2)+Θ(1)의 폐쇄형은?\r\n1)T(n)=Θ(logn)\r\n2)T(n)=Θ(n)\r\n3)T(n)=Θ(n²)\r\n4)T(n)=Θ(nlogn)",
        ITERATION: 2019,
        NO: 6,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 1,
    },
    {
        ANSWER: "최선, 합병, 4",
        TITLE: "점화식과 폐쇄형",
        QUESTION:
            "퀵 정렬 (최선/최악), ㅇㅇ 정렬 알고리즘의 성능으로 T(1)=Θ(1), T(n)=2T(n/2)+Θ(n)의 폐쇄형은?\r\n1)T(n)=Θ(logn)\r\n2)T(n)=Θ(n)\r\n3)T(n)=Θ(n²)\r\n4)T(n)=Θ(nlogn)",
        ITERATION: 2019,
        NO: 6,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 1,
    },
    {
        ANSWER: "분할, 정복, 결합",
        TITLE: "분할정복 방법",
        QUESTION:
            "분할정복 방법에서 각 순환 호출마다 거치는 작업의 단계: ㅇㅇ -> ㅇㅇ -> ㅇㅇ",
        ITERATION: 2019,
        NO: 6,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 1,
    },
    {
        ANSWER: "25, 10, 20, 15",
        TITLE: "퀵 정렬",
        QUESTION:
            "다음 데이터에 대해서 분할 함수 Partition()을 한 번 적용한 후 왼쪽 부분배열에 존재하는 데이터를 순서대로 기입하시오.\r\n(단, 피벗은 맨 왼쪽 원소이고, 오름차순으로 정렬한다.)\r\n [30, 45, 20, 15, 40, 25, 35, 10]",
        ITERATION: 2019,
        NO: 6,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 2,
    },
    {
        ANSWER: "최악, 최악, 최선, 최악, 최선",
        TITLE: "퀵 정렬의 성능",
        QUESTION:
            "- 분할을 수행할 때마다 항상 피벗이 최솟값 또는 최댓값이 되는 경우: (최선/최악)의 성능\r\n- 피벗만 제자리를 잡고 나머지 모든 데이터가 하나의 부분배열이 되는 경우: (최선/최악)의 성능\r\n - 피벗이 항상 중간값이 되는 경우: (최선/최악)의 성능\r\n- 입력 데이터가 정렬되어 있는 경우: (최선/최악)의 성능\r\n- 피벗을 중심으로 항상 동일한 크기의 두 부분배열로 분할되는 경우: (최선/최악)의 성능\r\n",
        ITERATION: 2019,
        NO: 10,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 2,
    },
    {
        ANSWER: "36",
        TITLE: "퀵 정렬 피벗",
        QUESTION:
            "다음은 입력 크기 38인 배열의 원소를 7개의 그룹으로 구성한 모습이다. 최악 O(n)으로 i번째로 작은 원소를 찾기 위한 선택 문제에서 피벗으로 선택되는 원소는? \r\n[9, 6, 35, 39, 15]\r\n[24, 70, 95, 50, 1]\r\n[97, 84, 77, 28, 10]\r\n[22, 27, 11, 31, 62]\r\n[54, 81, 5, 34, 4]\r\n[89, 60, 29, 2, 75]\r\n[18, 36, 80, 7, 53]\r\n[25, 66, 43]",
        ITERATION: 2019,
        NO: 11,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 2,
    },
    {
        ANSWER: "스트링, 상향, 최적, X",
        TITLE: "동적 프로그래밍 방법",
        QUESTION:
            "- 모든 정점 간의 최단 경로 문제와 ㅇㅇㅇ 편집 거리 문제에 적용된다. \r\n-(상향/하향)식 접근 방법 \r\n- ㅇㅇ성의 원리가 만족되는 문제에만 적용할 수 있다. \r\n- 소문제들은 서로 독립적이어야 한다. (O/X)",
        ITERATION: 2019,
        NO: 12,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 5,
    },
    {
        ANSWER: 13,
        TITLE: "피보나치 수열",
        QUESTION:
            "피보나치 수열 f(n)에서 f(7)은 얼마인가? \r\n (단, f(0) = 0, f(1) = 1이다.)",
        ITERATION: 2019,
        NO: 13,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 5,
    },
    {
        ANSWER: 4,
        TITLE: "행렬의 연쇄적 곱셈",
        QUESTION:
            "동적 프로그래밍 방법을 적용하여 n개의 행렬에 대한 연쇄적 곰셈 문제를 해결하는 알고리즘의 시간 복잡도는?\r\n1)O(nlogn)\r\n2)O(n)\r\n3)O(n²)\r\n4)O(n³)",
        ITERATION: 2019,
        NO: 14,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 5,
    },
    {
        ANSWER: 4,
        TITLE: "플로이드 알고리즘",
        QUESTION:
            "플로이드 알고리즘의 성능 표현으로 올바른 것은? \r\nFloyd (G=(V,E)) { // |V|=n \r\nD[][] <- 입력 간선의 인접 행렬로 초기화\r\nfor (k=1부터 n까지)\r\nfor (i=1부터 n까지)\r\nfor (j=1부터 n까지)\r\nif (D[i][j] > D[i][k] + D[k][j])\r\nD[i][j] = D[i][k] + D[k][j];\r\nreturn D[][];\r\n}\r\n1)O(nlogn)\r\n2)O(n)\r\n3)O(n²)\r\n4)O(n³)",
        ITERATION: 2019,
        NO: 15,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 4,
    },
    {
        ANSWER: "크루스칼, 프림, 데이크스트라",
        TITLE: "욕심쟁이(greedy) 대표 고리즘",
        QUESTION:
            "- 최소 신장 트리: ㅇㅇㅇㅇ 알고리즘, ㅇㅇ 알고리즘 \r\n- 단일 출발점에 대한 최단 경로: ㅇㅇㅇㅇㅇㅇ 알고리즘",
        ITERATION: 2019,
        NO: 17,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 1,
    },
    {
        ANSWER: "가중, 작은",
        TITLE: "최소 신장 트리",
        QUESTION:
            "최소 신장 트리는 신장 트리 중에서 ㅇㅇ치의 합이 가장 (큰/작은) 것",
        ITERATION: 2019,
        NO: 18,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 4,
    },
    {
        ANSWER: "T6",
        TITLE: "욕심쟁이 방법",
        QUESTION:
            "욕심쟁이 방법을 적용한 작업 선택 문제에서 기계에 가장 먼저 할당되는 작업은? \r\nT1 = (0, 4), T2 = (4, 8), T3 = (6, 9), T4 = (9, 10), T5 = (1, 6), T6 = (1, 3), T7 = (3, 8), T8 = (4, 6)",
        ITERATION: 2019,
        NO: 19,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 1,
    },
    {
        ANSWER: "비교, 분포",
        TITLE: "정렬 알고리즘",
        QUESTION:
            "- ㅇㅇ 기반의 알고리즘: 선택 정렬, 버블 정렬, 삽입 정렬, 셸 정렬, 퀵 정렬, 합병 정렬, 힙 정렬 \r\n - 데이터의 ㅇㅇ에 기반한 정보를 바탕으로 정을 수행하는 알고리즘: 계수 정렬, 기수 정렬, 버킷 정렬",
        ITERATION: 2019,
        NO: 20,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 2,
    },
    {
        ANSWER: "유지, 불안정, 안정, 안정, 불안정, 불안정, 안정, 불안정, 안정",
        TITLE: "안정적 정렬",
        QUESTION:
            "안정적 정렬은 같은 값을 갖는 여러 개의 데이터에 대한 정렬 전의 상대적 위치가 정렬 후에도 그대로 ㅇㅇ되는 정렬이다.\r\n - 선택 정렬: (안정/불안정)\r\n - 버블 정렬: (안정/불안정)\r\n - 삽입 정렬: (안정/불안정)\r\n - 셸 정렬: (안정/불안정)\r\n - 퀵 정렬: (안정/불안정)\r\n - 합병 정렬: (안정/불안정)\r\n - 힙 정렬: (안정/불안정)\r\n - 데이터 분포 기반의 정렬: (안정/불안정)",
        ITERATION: 2019,
        NO: 21,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 2,
    },
    {
        ANSWER: "10",
        TITLE: "버블 정렬",
        QUESTION:
            "다음 데이터에 대해 버블 정렬을 적용하여 오름차순으로 정렬할 때, 인접한 두 데이터 간의 자리바꿈이 발생하는 총 횟수는? \r\n [50, 40, 30, 20, 10]",
        ITERATION: 2019,
        NO: 22,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 2,
    },
    {
        ANSWER: "선택",
        TITLE: "ㅇㅇ 정렬",
        QUESTION:
            "정렬되지 않은 데이터 중에서 가장 작은 값을 골라서, 이 값과 미정렬 데이터 부분의 첫 번째 원소와 교환하는 방식",
        ITERATION: 2019,
        NO: 23,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 2,
    },
    {
        ANSWER: "O, 안정, O, O",
        TITLE: "삽입 정렬",
        QUESTION:
            "- 입력이 정렬된 상태로 주어지는 최선의 경우 수행시간은 O(n)이다. (O/X)\r\n- (안정/불안정)적인 정렬 알고리즘\r\n- 제자리 정렬 알고리즘이다. (O/X)\r\n- 최악의 수행시간은 O(n²)이다. (O/X)",
        ITERATION: 2019,
        NO: 24,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 2,
    },
    {
        ANSWER: "nlogn, nlogn, 안정, X, O",
        TITLE: "합병 정렬",
        QUESTION:
            "- 최악의 수행시간은 O((n/nlogn))이다. \r\n- 최선의 수행시간은 O((n/nlogn))이다.\r\n- (안정/불안정)적인 정렬 알고리즘\r\n- 제자리 정렬 알고리즘이다. (O/X)\r\n- 분할정복 방법이 적용되었다. (O/X)",
        ITERATION: 2019,
        NO: 25,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 2,
    },
    {
        ANSWER: "O, nlogn, 불안정, O, O",
        TITLE: "퀵 정렬",
        QUESTION:
            "- 최악의 수행시간은 O(n²)이다. (O/X)\r\n- 최선의 수행시간은 O((n/nlogn))이다.\r\n- (안정/불안정)적인 정렬 알고리즘\r\n- 제자리 정렬 알고리즘이다. (O/X)\r\n- 분할정복 방법이 적용되었다. (O/X)",
        ITERATION: 2019,
        NO: 26,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 2,
    },
    {
        ANSWER: "제자리, 넘지 않는",
        TITLE: "ㅇㅇㅇ 정렬 알고리즘",
        QUESTION:
            "입력 데이터를 저장하는 공간 이외에 별도로 필요한 저장 공간이 상수 개를 (넘는/넘지 않는) 정렬 알고리즘",
        ITERATION: 2019,
        NO: 26,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 2,
    },
    {
        ANSWER: "88",
        TITLE: "힙 정렬",
        QUESTION:
            "주어진 데이터를 오름차순으로 힙 정렬할 때, 루트 노드에 존재하는 데이터는? \r\n [10, 7, 15, 88, 50, 30, 40]",
        ITERATION: 2019,
        NO: 27,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 2,
    },
    {
        ANSWER: "X, 상수, X, 안정, n",
        TITLE: "기수 정렬",
        QUESTION:
            "- 비교 기반의 정렬 알고리즘이다. (O/X)\r\n - 입력 데이터의 자릿수가 ㅇㅇ일 때 유용하다.\r\n - 제자리 정렬 알고리즘이다. (O/X)\r\n - (안정/불안정) 정렬 알고리즘이다.\r\n - 시간 복잡도는 O((n/n의 제곱))이다.",
        ITERATION: 2019,
        NO: 28,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 2,
    },
    {
        ANSWER: "비정렬, 작은, O, 1, n, n, 1",
        TITLE: "순차 탐색",
        QUESTION:
            "- (정렬/비정렬) 데이터에 적합하다.\r\n - 크기가 (큰/작은) 데이터에 적합하다.\r\n - 리스트 형태의 입력에 언제라도 적용이 가능하다. (O/X)\r\n - 탐색 키가 존재하는 경우에는 최소 (1/n)번의 비교가 필요하다.\r\n - 탐색 키가 존재하지 않는 경우 항상 (n의 제곱/n)번의 비교가 필요하다.\r\n - 탐색과 삭제 연산의 시간 복잡도는 O((n/n의 제곱))이다.\r\n - 삽입 연산의 시간 복잡도는 O((1/n/logn))이다.",
        ITERATION: 2019,
        NO: 29,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 3,
    },
    {
        ANSWER: "정렬, 작은, logn, nlogn, n",
        TITLE: "이진 탐색",
        QUESTION:
            "- (정렬/비정렬) 데이터에 적합하다.\r\n - 크기가 (큰/작은) 데이터에 적합하다.\r\n - 탐색 연산의 시간 복잡도는 O((n/logn/nlogn))이다.\r\n - 초기화 연산의 시간 복잡도는 O((n/logn/nlogn))이다.\r\n - 삽입과 삭제 연산의 시간 복잡도는 O((n/logn/nlogn))이다.",
        ITERATION: 2019,
        NO: 30,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 3,
    },
    {
        ANSWER: "균형, 검정, 검정, 검정, 작다, 크다",
        TITLE: "레드-블랙 트리(흑적 트리)",
        QUESTION:
            "흑적 트리는 모든 노드에 대해 다음 성질을 만족하는 이진 트리인 ㅇㅇ 탐색 트리이다. \r\n- 모든 노드는 검정이거나 빨강이다. \r\n- 루프 노드와 리프 노드는 (검정/빨강)이다.\r\n- 빨강 노드의 부모 노드는 항상 (검정/빨강)이다.\r\n- 임의의 노드로부터 리프 노드까지의 경로상에는 동일한 개수의 (검정/빨강) 노드가 존재한다.\r\n- 한 노드의 왼쪽 서브트리에 있는 모든 키 값은 그 노드의 키값보다 (작다/크다).\r\n- 한 노드의 오른쪽 서브트리에 있는 모든 키 값은 그 노드의 키값보다 (크다/작다).",
        ITERATION: 2019,
        NO: 31,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 3,
    },
    {
        ANSWER: 4,
        TITLE: "탐색 트리",
        QUESTION:
            "모든 리프 노드의 레벨이 동일한 트리는? \r\n 1) 흑적 트리\r\n 2) 이진 탐색 트리\r\n 3) 완전 이진 트리\r\n 4) B-트리",
        ITERATION: 2019,
        NO: 32,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 3,
    },
    {
        ANSWER: "1, logn, logn, n, logn, logn, logn",
        TITLE: "탐색 연산의 시간 복잡도",
        QUESTION:
            "- 이진 탐색 최선: O((1/n/logn))\r\n- 이진 탐색 최악: O((n/logn/nlogn))\r\n- 이진 탐색 트리 최선: O((1/n/logn))\r\n- 이진 탐색 트리 최악: O((n/logn/nlogn))\r\n- 2-3-4 트리: O((n/logn/nlogn))\r\n- 레드-블랙 트리: O((n/logn/nlogn))\r\n- B-트리: O((n/logn/nlogn))\r\n",
        ITERATION: 2019,
        NO: 33,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 3,
    },
    {
        ANSWER: 2,
        TITLE: "근사 알고리즘",
        QUESTION:
            "다음 NP-완전 문제의 근사 알고리즘을 통해 해결할 수 있는 문제는? \r\n- 주어진 그래프의 최소 신장 트리를 구한다.\r\n- 임의의 정점 하나를 루트 노드로 지정해서 최소 신장 트리를 깊이 우선 탐색 순서대로 정점을 나열하고 마지막에 첫 정점을 한 번 더 추가한다.\r\n1) 버텍스 커버 문제\r\n2) 외판원 문제\r\n3) CNF-만족성 문제\r\n4) 클리크 판정 문제",
        ITERATION: 2019,
        NO: 35,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 7,
    },

    //============================== 2018
    {
        ANSWER: "컴퓨터, 명확, O, 0, 1",
        TITLE: "알고리즘의 조건",
        QUESTION:
            "- 모든 명령은 ㅇㅇㅇ에서 수행 가능해야 한다. \r\n- 각 명령은 단순하고 ㅇㅇ해야 한다.\r\n- 한정된 수의 단계를 거친 후에는 반드시 끝나야 한다. (O/X)\r\n- 외부에서 (0/1)개 이상의 입력을 받아서 (0/1)개 이상의 출력을 생성해야 한다.",
        ITERATION: 2018,
        NO: 2,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 1,
    },
    {
        ANSWER: 8,
        TITLE: "이진 트리",
        QUESTION:
            "최대 개수의 노드를 갖는 높이 4인 이진 트리에서 단말 노드의 개수는?",
        ITERATION: 2018,
        NO: 3,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 4,
    },
    {
        ANSWER: "수행, 4",
        TITLE: "알고리즘의 시간 복잡도",
        QUESTION:
            "시간 복잡도는 알고리즘의 ㅇㅇ시간이다. 이는 무엇의 함수로 표현하는가? \r\n1) 입력 데이터의 값\r\n2) 프로그램에 사용된 동적 변수의 개수\r\n3) 프로그램 코드의 길이\r\n4) 입력 데이터의 크기",
        ITERATION: 2018,
        NO: 4,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 1,
    },
    {
        ANSWER: "독립, 하향, 분할, 정복, 결합",
        TITLE: "분할정복 방법",
        QUESTION:
            "- 분할된 작은 문제는 서로 ㅇㅇ적이다.\r\n- (상향/하향)식 접근 방법\r\n- ㅇㅇ, ㅇㅇ, ㅇㅇ의 처리 과정을 거친다.",
        ITERATION: 2018,
        NO: 6,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 1,
    },
    {
        ANSWER: "상향, 점화",
        TITLE: "동적 프로그래밍 방법",
        QUESTION:
            "- (상향/하향)식 접근 방법\r\n- ㅇㅇ식을 이용해서 보다 큰 문제의 해를 구한다.",
        ITERATION: 2018,
        NO: 6,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 1,
    },
    {
        ANSWER: 4,
        TITLE: "퀵 정렬",
        QUESTION:
            "퀵 정렬 최악의 시간 복잡도에 해당하는 점화식은? \r\n1) T(1)=Θ(1), T(n)=2T(n/2)+Θ(n)\r\n2) T(1)=Θ(1), T(n)=T(n-1)+Θ(1)\r\n3) T(1)=Θ(1), T(n)=T(n/2)+Θ(1)\r\n4) T(1)=Θ(1), T(n)=T(n-1)+Θ(n)",
        ITERATION: 2018,
        NO: 8,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 1,
    },
    {
        ANSWER: 5,
        TITLE: "퀵 정렬",
        QUESTION:
            "중간값들의 중간값을 사용하는 선택 문제에서 각 그룹은 몇 개의 원소로 구성되는가?",
        ITERATION: 2018,
        NO: 9,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 2,
    },
    {
        ANSWER: "플로이드, 동적 프로그래밍, 분할정복, 분할정복, 욕심쟁이",
        TITLE: "알고리즘 설계기법",
        QUESTION:
            "다음의 알고리즘과 설계기법을 매칭하라. \r\n - 모든 정점 간의 최단 경로 구하는 알고리즘(ㅇㅇㅇㅇ 알고리즘): (욕심쟁이/분할정복/동적 프로그래밍) 방법\r\n - 합병 정렬: (욕심쟁이/분할정복/동적 프로그래밍) 방법\r\n - 최솟값과 최댓값을 모두 찾는 알고리즘: (욕심쟁이/분할정복/동적 프로그래밍) 방법\r\n - 작업 선택 문제: (욕심쟁이/분할정복/동적 프로그래밍) 방법",
        ITERATION: 2018,
        NO: 10,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 1,
    },
    {
        ANSWER: 30,
        TITLE: "행렬의 연쇄적 곱셈",
        QUESTION:
            "다음과 같이 6개의 행렬을 곱할 때, C(1,2)의 값은? \r\n M1 x M2 x M3 x M4 x M5 x M6 \r\n 5 x 2, 2 x 3, 3 x 4, 4 x 6, 6 x 7, 7 x 8",
        ITERATION: 2018,
        NO: 11,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 5,
    },
    {
        ANSWER: "이하, 경유, 최단",
        TITLE: "플로이드 알고리즘",
        QUESTION:
            "모든 정점 간의 최단 경로를 구할 때, d₄₃²은 정점 번호가 2 (이상/이하)인 정점만을 ㅇㅇ하는 정점 4에서 정점 3까지의 ㅇㅇ 경로 길이라고 한다.",
        ITERATION: 2018,
        NO: 12,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 5,
    },
    {
        ANSWER: "정수",
        TITLE: "동적 프로그래밍 방법",
        QUESTION: "저울 문제에서 추의 무게는 ㅇㅇ이어야 한다.",
        ITERATION: 2018,
        NO: 13,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 5,
    },
    {
        ANSWER: "X, 큰, 4",
        TITLE: "거스름돈 문제",
        QUESTION:
            "- 동전의 액면가가 임의로 주어지는 경우에도 욕심쟁이 방법으로 해결할 수 있다. (O/X)\r\n 동전의 액면가가 (큰/작은) 것 부터 최대한 사용해서 거스름돈을 만든다.\r\n 동전의 종류가 500원, 100원, 50원, 10원이면 거스름돈 750원에 대한 최적해는 ㅇ개이다.",
        ITERATION: 2018,
        NO: 14,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 1,
    },
    {
        ANSWER: "1",
        TITLE: "최소 신장 트리",
        QUESTION:
            "다음 중 최소 신장 트리를 구하는 알고리즘은? \r\n1) 크루스칼 알고리즘\r\n2) 플로이드 알고리즘\r\n3) 데이크스트라 알고리즘\r\n4) KMP 알고리즘",
        ITERATION: 2018,
        NO: 15,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 1,
    },
    {
        ANSWER: "t5",
        TITLE: "작업 스케줄링",
        QUESTION:
            "다음 작업에 대한 작업 스케줄링 문제의 최적해를 구하려고 한다. 가장 먼저 기계에 할당하는 작업은?\r\n t1=(2, 5), t2=(6, 9), t3=(4, 9), t4=(1, 4), t5=(0, 7), t6=(9, 10), t7=(7, 10), t8=(5, 8)",
        ITERATION: 2018,
        NO: 16,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 1,
    },
    {
        ANSWER: "큰, d",
        TITLE: "데이터 압축 - 허프만 코딩",
        QUESTION:
            "텍스트 abcdbcdcdd를 허프만 코딩으로 인코딩하였을 때 가장 짧은 코드가 부여되는 문자는 빈도수가 가장 (큰/작은) 문자이므로 ㅇ이다.",
        ITERATION: 2018,
        NO: 17,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 6,
    },
    {
        ANSWER: "X, O, 불안정, O, 작은",
        TITLE: "선택 정렬",
        QUESTION:
            "- 입력 데이터의 상태에 따라 성능이 달라진다. (O/X)\r\n- 입력 데이터와 무관하게 언제나 동일한 시간 복잡도를 갖는다. (O/X)\r\n- (안정/불안정)적인 정렬 알고리즘\r\n- 제자리 정렬 알고리즘이다. (O/X)\r\n- 오름차순 정렬의 경우 주어진 데이터 중에서 가장 (작은/큰) 값부터 골라 차례로 나열한다.",
        ITERATION: 2018,
        NO: 20,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 2,
    },
    {
        ANSWER: "셸, n의 제곱, nlogn, 불안정, O",
        TITLE: "ㅇ 정렬",
        QUESTION:
            "- 삽입 정렬의 단점을 보완한 정렬 알고리즘\r\n- 최악의 경우 시간 복잡도: O((n/logn/n의 제곱/nlogn))\r\n- 최선의 경우 시간 복잡도: O((n/logn/n의 제곱/nlogn))\r\n- (안정/불안정)적인 정렬 알고리즘\r\n- 제자리 정렬 알고리즘이다. (O/X)",
        ITERATION: 2018,
        NO: 22,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 2,
    },
    {
        ANSWER: 4,
        TITLE: "정렬 알고리즘",
        QUESTION:
            "평균적인 성능이 O(nlogn)인 안정적인 알고리즘은? \r\n1) 퀵 정렬\r\n2) 셸 정렬\r\n3) 힙 정렬\r\n4) 합병 정렬",
        ITERATION: 2018,
        NO: 23,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 2,
    },
    {
        ANSWER: 4,
        TITLE: "정렬 알고리즘",
        QUESTION:
            "비교 기반 알고리즘 중에서 정렬 과정에서 입력 크기에 비례하는 만큼의 추가적인 저장 공간을 요구하는 것은? \r\n1) 퀵 정렬\r\n2) 셸 정렬\r\n3) 힙 정렬\r\n4) 합병 정렬",
        ITERATION: 2018,
        NO: 24,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 2,
    },
    {
        ANSWER: "초기 힙, 크, 최대, 재구성",
        TITLE: "힙 정렬",
        QUESTION:
            "- 첫 번째 단계: 주어진 배열을 ㅇㅇ ㅇ으로 변환한다. 각 노드의 값은 자식 노드의 값보다 (크/작)거나 같다. \r\n- 두 번째 단계: 데이터의 개수만큼 반복하면서 (최소/최대)값을 삭제하고 힙으로 ㅇㅇㅇ하는 과정",
        ITERATION: 2018,
        NO: 25,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 2,
    },
    {
        ANSWER: "70, 60, 50, 40, 20, 30, 10, 80",
        TITLE: "힙 정렬",
        QUESTION:
            "다음 배열에 대해 오름차순으로 정렬하는 힙 정렬의 두 번째 단계를 한 번 수행한 후의 배열의 상태를 올바르게 표현하면? \r\n[80, 60, 70, 40, 20, 30, 50, 10]",
        ITERATION: 2018,
        NO: 25,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 2,
    },
    {
        ANSWER: "계수, 선형, 안정, X",
        TITLE: "ㅇㅇ 정렬",
        QUESTION:
            "- 주어진 원소 중에서 자신보다 작거나 같은 값을 갖는 원소의 개수를 계산하여 정렬할 위치를 찾아 정렬하는 방법\r\n- ㅇㅇ 시간의 성능을 가짐.\r\n- (안정/불안정)적인 정렬 알고리즘\r\n- 제자리 정렬 알고리즘이다. (O/X)",
        ITERATION: 2018,
        NO: 26,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 2,
    },
    {
        ANSWER: "h, n, logn",
        TITLE: "이진 탐색 트리 탐색 연산",
        QUESTION:
            "- 높이가 h라면 탐색 연산의 시간 복잡도는 O((h/logh/2h/0.5h))이다. \r\n- 최악의 탐색 성능을 갖는 경우, 입력 크기 n에 대한 시간 복잡도는 O((n/logn/n의 제곱/nlogn))\r\n- 최선의 탐색 성능을 갖는 경우, 시간 복잡도는 O((n/logn/n의 제곱/nlogn))",
        ITERATION: 2018,
        NO: 27,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 3,
    },
    {
        ANSWER: "리프, 후속자",
        TITLE: "이진 탐색 트리 삭제 연산",
        QUESTION:
            "- 자식 노드가 없는 경우: 삭제되는 노드가 ㅇㅇ 노드이므로 남은 노드가 없어 위치 조절 필요없다. \r\n- 자식 노드가 하나인 경우: 자식 노드를 삭제되는 노드의 위치로 올리면서 서브 트리 전체도 따라 올린다.\r\n- 자식 노드가 2개인 경우: 삭제 노드의 바로 다음 키값을 갖는 노드인 ㅇㅇㅇ 노드를 삭제 노드의 위치로 올린다.",
        ITERATION: 2018,
        NO: 28,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 3,
    },
    {
        ANSWER: "2t-1, t-1",
        TITLE: "B-트리의 삽입 연산",
        QUESTION:
            "- 탐색할 자식 노드가 없으면 현재 리프 노드에 키로 추가한다. \r\n- 탐색 과정에서 키의 개수가 (t/2t/2t-1/2t+1)인 노드를 만다면 항상 노드 분할이 발생한다.\r\n- 노드 분할은 노드 하나를 (t/t-1/t+1)개의 키를 갖는 2개의 노드로 분할하는 것으로, 가운데 키를 부모 노드로 올린다.",
        ITERATION: 2018,
        NO: 30,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 3,
    },
    {
        ANSWER: "개방, 폐쇄, 버, 선, 이, 이",
        TITLE: "해시 테이블 - 충돌 해결 방법",
        QUESTION:
            "- ㅇㅇ 해싱: 충돌된 데이터를 해시 테이블 밖의 별도의 장소에 저장 \r\n- ㅇㅇ 해싱: 충돌된 데이터를 해시 테이블 내의 다른 위치에 저장, ㅇ킷 해싱, ㅇ형 탐사, ㅇ차 탐사, ㅇ중 해싱 등",
        ITERATION: 2018,
        NO: 31,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 3,
    },
    {
        ANSWER: "주소, 제산, 비닝, 중간",
        TITLE: "해시 함수",
        QUESTION:
            "- 키 값을 해시 테이블의 ㅇㅇ로 변환하는 함수 \r\n- 종류: ㅇㅇ 잔여법, ㅇㅇ, ㅇㅇ 제곱법 등",
        ITERATION: 2018,
        NO: 31,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 3,
    },
    {
        ANSWER: "사이클, 정규곱, 클리크, 정점, 최소, 외판원, 1, 무한",
        TITLE: "NP-완전 문제",
        QUESTION:
            "- 해밀토니언 ㅇㅇㅇ 문제: 무방향 그래프 G가 주어졌을 때, G의 모든 정점을 한 번씩만 지나가는 사이클이 존재하는지 판정 \r\n- CNF 만족성 문제: ㅇㅇㅇ형으로 주어진 논리식을 참으로 만들 수 있는지 판정 \r\n- ㅇㅇㅇ 판정 문제: 그래프 G가 크기가 k인 클리크(완전 그래프가 되는 G의 부분 그래프)를 갖는지 판정. 크기가 k인 클리크는 ㅇㅇ이 k개인 클리크이다. \r\n- 버텍스 커버 문제: 그래프가 크기 k인 버텍스 커버(그래프의 모든 간선이 부수하는 (최소/최대) 크기의 부분 집합)를 갖는지 판정 \r\n- ㅇㅇㅇ 문제: 비용 R 이하로 모든 도시를 한 번씩만 방문하고 처음 도시로 돌아오는 방법이 존재하는지 판정 \r\n- 통 채우기 문제: 용량이 (1/무한)인 (1/무한)개의 빈 통에 다양한 크기의 물체를 전부 담을 수 있는지 판정",
        ITERATION: 2018,
        NO: 32,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 7,
    },
    {
        ANSWER: "출발, 플로이드",
        TITLE: "그래프 - 최단 경로",
        QUESTION:
            "- 특정한 하나의 정점을 ㅇㅇ점으로 지정해서 다른 모든 정점으로의 최단 경로를 구하는 알고리즘: 데이크스트라, 벨만-포드 \r\n- 모든 정점 쌍 간의 최단 경로를 구하는 알고리즘: ㅇㅇㅇㅇ",
        ITERATION: 2018,
        NO: 32,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 4,
    },
    {
        ANSWER: "다항, 속한다",
        TITLE: "NP-완전 문제",
        QUESTION:
            "클래스 NP에 속하는 모든 문제가 문제 A로 ㅇㅇ 시간에 변환되면서, 문제 A가 클래스 NP에 (속한다/속하지 않는다)는 것을 보여야 한다.",
        ITERATION: 2018,
        NO: 33,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 7,
    },
    {
        ANSWER: "교차",
        TITLE: "유전 알고리즘의 연산",
        QUESTION:
            "ㅇㅇ: 부모의 형질을 나누어 갖는 연산으로, 다른 최적화 방법과 구별짓는 연산이다.",
        ITERATION: 2018,
        NO: 34,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 1,
    },
    {
        ANSWER: "순열",
        TITLE: "NP-완전 문제",
        QUESTION: "ㅇㅇ 인코딩: 외판원 문제에 가장 적합한 염색체 인코딩 방법",
        ITERATION: 2018,
        NO: 34,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 7,
    },

    //============================== 2017
    {
        ANSWER: 4,
        TITLE: "이진 트리",
        QUESTION:
            "깊이가 k인 이진 트리가 가질 수 있는 노드의 최대 개수는? \r\n1) 2^(k-1)\r\n2) 2^(k-1)-1\r\n3) 2^k\r\n4) 2^k-1",
        ITERATION: 2017,
        NO: 2,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 1,
    },
    {
        ANSWER: "분할정복, 욕심쟁이, NP-완전 문제",
        TITLE: "알고리즘 설계기법",
        QUESTION:
            "- 이진 탐색: (욕심쟁이/분할정복)\r\n - 거스름돈 문제: (욕심쟁이/분할정복) \r\n - 0/1 배낭 문제: (동적 프로그래밍/NP-완전 문제)",
        ITERATION: 2017,
        NO: 3,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 1,
    },
    {
        ANSWER: 4,
        TITLE: "버블 정렬",
        QUESTION:
            "한 단계의 수행 결과가 다음과 같을 때, 바로 다음 단계의 수행 결과를 얻기 위해서는 자리바꿈이 몇 번 발생하는가? \r\n 5(정렬), 35, 20, 10, 40, 25, 15, 30",
        ITERATION: 2017,
        NO: 8,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 2,
    },
    {
        ANSWER: "logn, n, logn",
        TITLE: "탐색 알고리즘 시간 복잡도",
        QUESTION:
            "- 이진 탐색: O((n/logn/nlogn))\r\n - 순차 탐색: O((n/logn/nlogn)) \r\n - 흑적 트리: O((n/logn/nlogn))",
        ITERATION: 2017,
        NO: 19,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 3,
    },
    {
        ANSWER: "3, 4, X",
        TITLE: "2-3-4 트리",
        QUESTION:
            "- 4-노드는 ㅇ개의 키와 ㅇ개의 자식을 갖는다. \r\n- 경사 트리가 발생한다. (O/X)",
        ITERATION: 2017,
        NO: 22,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 3,
    },
    {
        ANSWER: "양, 독립된",
        TITLE: "강연결 성분",
        QUESTION:
            "- 주어진 방향 그래프에서 임의의 두 정점 사이에 (단/양)방향의 경로가 존재하는 최대 부분 그래프 \r\n- 단방향 경로로 연결되는 정점은 (독립된/같은) 강연결 성분이다.",
        ITERATION: 2017,
        NO: 25,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 4,
    },
    {
        ANSWER: 23,
        TITLE: "허프만 코딩",
        QUESTION:
            "스트링 [abracadabra]를 허프만 코딩으로 압축하였을 때 인코딩된 메시지의 길이는 몇 비트인가?",
        ITERATION: 2017,
        NO: 30,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 6,
    },
    {
        ANSWER: "블록, 양자, 엔트로피",
        TITLE: "JPEG 표준의 압축 과정",
        QUESTION: "ㅇㅇ화 -> DCT -> ㅇㅇ화 -> ㅇㅇㅇㅇ 코딩",
        ITERATION: 2017,
        NO: 31,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 6,
    },
    {
        ANSWER: 3,
        TITLE: "알고리즘 설계 기법",
        QUESTION:
            "문자열 X를 문자열 Y로 변환하는 데 필요한 전체 편집 연산에 대한 최소 비용을 계산하는 문제를 가장 효과적으로 해결할 수 있는 기법은? \r\n1) 분할정복 방법\r\n2) 상각 분석 방법\r\n3) 동적 프로그래밍 방법\r\n4) 욕심쟁이 방법",
        ITERATION: 2017,
        NO: 32,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 1,
    },
    {
        ANSWER: "최적, 점화, 작은, 큰",
        TITLE: "동적 프로그래밍",
        QUESTION:
            "주어진 문제가 ㅇㅇ성의 원리를 만족하면 적용 가능하며, 다음과 같은 과정을 따른다.\r\n - 주어진 문제에 대해서 최적해를 제공하는 ㅇㅇ식을 도출한다. \r\n - 가장 (작은/큰) 문제부터 해를 구한 뒤 이를 테이블에 저장한다. \r\n - 테이블에 저장된 문제의 해를 이용하여 점차적으로 (큰/작은) 문제의 해를 구한다.",
        ITERATION: 2017,
        NO: 33,
        IS_CORRECT: false,
        IS_ENTERED: false,
        SUBJECT: 5,
    },

    //============================== 2016
];
